# 正则表达式练习题

## 小试身手

- 验证手机号码是否符合规则(不考虑边界问题)

  ```python
  规则如下：
  	1.都是数字 
  	2.长度为11 
  	3.第一位是1 
  	4.第二位是35678中的一位
  	
  #首先清楚手机号的规则
  #1.都是数字 2.长度为11 3.第一位是1 4.第二位是35678中的一位
   
  pattern = "1[35678]\d{9}"
  phoneStr = "18230092223"
   
  result = re.match(pattern, phoneStr)
  result.group()
  
  ```

  

- 匹配原始字符串

  ```python
  1.匹配"\nabc"
  
   	在给str赋值"\nabc"前加上"r"之后,python解释器会自动给str	的值"\nabc"在加上一个"\".
      使str在被打印的时候,能够保持原始字符串的值"\nabc"打印出来
      
  2.匹配"\\abc"
  
  ```

  

- 匹配边界（定义规则匹配str="this is book"）

  ```python
  import re
   
  #定义规则匹配str="this is book"
  #1. 以字母开始
  #2. 中间有空字符
  #3. is两边分别限定匹配单词边界
   
  pattern = r"^\w+\s\bis\b\s\w+"
  str = "this is book"
  result = re.match(pattern, str)
  result.group()
  ```

  

- 匹配出0-100之间的数字

  ```python
  import re
   
  #匹配出0-100之间的数字
  #首先:正则是从左往又开始匹配
  #经过分析: 可以将0-100分为三部分
  #1. 0        "0$"
  #2. 100      "100$"
  #3. 1-99     "[1-9]\d{0,1}$"
  #所以整合如下
   
  pattern = r"0$|100$|[1-9]\d{0,1}$"
  #测试数据为0,3,27,100,123
  result = re.match(pattern, "27")
  result.group()
   
  #将0考虑到1-99上,上述pattern还可以简写为:pattern=r"100$|[1-9]?\d{0,1}$"
  ```

  

- 匹配分组,获取页面中的<h1>标签中的内容(爬虫会用到:

  str = "<h1>hello world!<h1>")

  ```python
  import re
  #匹配分组,获取页面<h1>标签中的内容, 爬虫的时候会用到
   
  str = "<h1>hello world!</h1>"
  pattern = r"<h1>(.*)</h1>"
  result = re.match(pattern, str)
  result.group()
  ```

- 分组引用, 精确获取多个标签内的内容

  ```python
  import re
   
  #引用分组,精确获取多个标签内的内容
  #"\1"是对第一个分组的引用,同理......
   
  str = "<span><h1>hello world!</h1></span>"
  pattern = r"<(.+)><(.+)>.*</\2></\1>"
  result = re.match(pattern, str)
  result.groups()
  
  ```

- 分组起别名

  ```python 
  import re
   
  #分组起别名
   
  str = "<span><h1>hello world!</h1></span>"
  pattern = "<(?P<key1>.+)><(?P<key2>.+)>(?P<nr>.*)</(?P=key2)></(?P=key1)>"
  result = re.match(pattern, str)
  result.group()
  ```

- 贪婪模式(尽可能多的匹配字符：匹配：4-235-22-423)

  ```python 
  import re
   
   
  str = "This is a number 234-235-22-423"
  pattern = r"(.+)(\d+-\d+-\d+-\d+)"
  result = re.match(pattern, str)
  result.groups()
  
  #分析 
  #由pattern可知str被分成两组,因为默认情况下为贪婪模式,所以
  #    第一组会在保证第二组符合的情况下, 尽可能的匹配多的字符
  #所以推断:
  #    第一组: This is a number 23
  #    第二组: 4-235-22-423
  # 这样既可以是第二组情况符合,而又使得第一组尽可能贪婪地匹配到最多的字符
  
  ```

- 非贪婪模式:(尽可能少的匹配字符，`?`加载表达式后,可以开启非贪婪模式：匹配：234-235-22-423)

  ```Python
  import re
   
  #非贪婪模式(尽可能少的匹配字符,看例子)
   
  str = "This is a number 234-235-22-423"
  pattern = r"(.+?)(\d+-\d+-\d+-\d+)"
  result = re.match(pattern, str)
  result.groups()
   
   
  #分析 
  #由pattern可知str被分成两组,因为使用?所以为非贪婪模式,所以
  #    第一组会在保证第二组符合的情况下, 尽可能的匹配少的字符
  #所以推断:
  #    第一组: This is a number 
  #    第二组: 234-235-22-423
  # 这样既可以是第二组情况符合,而又使得第一组尽可能匹配到最少的字符
  ```

- 匹配邮箱

  ```Python
  1、匹配163邮箱
  str = "zhangxinwei_user@163.com"
  result = re.match(r'[0-9a-zA-Z_]{0,19}@163.com',str)
  result.groups()
  2、匹配任意格式的邮箱
  text = "lvzezhang126@126.com"
  re.findll(r'^[0-9a-zA-Z_]{0,19}@[0-9a-zA-Z]{1,13}\.[com,cn,net]{1,3}$',text)
  ```

## 提取高考日期

- 一般来说，我们填写日期都会写2020年7月7日，但是也有很多人会写成2020/7/7、2020-7-7、2020-07-07等，还有的人可能会写为2020-07或者2020年7月。总之对日期的写法五花八门，那么我们现在需要写一个正则表达式来统一匹配这么多的情况，应该如何来处理呢？

  ```python
  str01 = "xxx高考时间是2020年7月7日"
  str02 = "xxx高考时间是2020/7/7"
  str03 = "xxx高考时间是2020-7-7日"
  str04 = "xxx高考时间是2020-07-07"
  str05 = "xxx高考时间是2020-07"
  str06 = "xxx高考时间是2020年7月"
  ```

- ```Python
  import re
  
  str01 = "xxx高考时间是2020年7月7日"
  str02 = "xxx高考时间是2020/7/7"
  str03 = "xxx高考时间是2020-7-7"
  str04 = "xxx高考时间是2020-07-07"
  str05 = "xxx高考时间是2020-07"
  str06 = "xxx高考时间是2020年7月"
  regex_str = ".*高考时间是(\d{4}[年/-]\d{1,2}[月/-](\d{1,2}(日|$)))"
  
  print(re.findall(regex_str,str06)[0][0])
  
  
  
  1、我们从左到右对正则表达式进行分析，首先“.*”代表的是任意字符出现任意多次，对应原始字符中的“XXX”；“高考时间是”没有什么特别的，就是对应原始字符串中的“高考时间是”。
  
  2、接下来是“d{4}”代表的是连续出现4个数字，对应原始字符串中的年份“2018”；“[年/-]”表示取“年”、“/”、“-”中的任意一个字符，对应原始字符串中年份“2018”之后所连接的下一个字符。
  
  3、继续往后是“d{1,2}”代表的是连续出现1个到2个数字，对应原始字符串中的月份“6”或者“06”；“[月/-]”表示取“月”、“/”、“-”中的任意一个字符，对应原始字符串中月份“6”或者“06”之后所连接的下一个字符，同年份的理解如出一辙。
  
  4、接下来就复杂一些了，其中“d{1,2}”的理解同月份的理解一致，关键是关于“日”的提取主要需要注意有的字符串有日期，有的字符串并没有日期，所以需要特殊字符“|”来表示“或”的关系，并且用特殊字符“$”来表示结束。
  
  
  5、需要利用特殊字符“|”和特殊字符“$”，做一个“或”的选择。
  regex_str = 
  ".*高考时间是(\d{4}[年/-]\d{1,2}([月/-]|$)(\d{1,2}(日|$)|$))"
  ```

  

